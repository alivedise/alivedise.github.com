
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Ascheriit</title>
	<meta name="author" content="Alive Kuo">

	
	<meta name="description" content="$.Controller - jQuery plugin factory JavaScriptMVC&#8217;s controllers are many things. They are a jQuery plugin factory. They can be used as a &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Ascheriit" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Ascheriit</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:alivedise.github.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/alivedise" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/alivedise" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:alivedise.github.com">
	</form>
</nav>

</header>
	
		
<div id="banner" class="inner">
	<div class="container">
		<ul class="feed"></ul>
	</div>
	<small><a href="http://twitter.com/alivedise">alivedise</a> @ <a href="http://twitter.com">Twitter</a></small>
	<div class="loading">Loading...</div>
</div>
<script src="/javascripts/twitter.js"></script>
<script type="text/javascript">
	(function($){
		$('#banner').getTwitterFeed('alivedise', 4, false);
	})(jQuery);
</script>

	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2012/02/07/jmvc-controller/">
		
			[javascriptMVC] JMVC導覽 - $.Controller</a>
	</h2>
	<div class="entry-content">
		<h2>$.Controller - jQuery plugin factory</h2>

<p>JavaScriptMVC&#8217;s controllers are many things.  They are a jQuery plugin factory.  They can be used as a traditional view, making pagination widgets and grid controls.  Or, they can be used as a traditional controller, initializing and controllers and hooking them up to models.  Mostly, controller&#8217;s are a really great way of organizing your application&#8217;s code.</p>

<p>Controllers provide a number of handy features such as:</p>

<ul>
<li>jQuery plugin creation</li>
<li>automatic binding</li>
<li>default options</li>
<li>automatic determinism</li>
</ul>


<p>But controller&#8217;s most important feature is not obvious to any but the most hard-core JS ninjas.  The following code creates a tooltip like widget that displays itself until the document is clicked.</p>

<pre><code>$.fn.tooltip = function(){
    var el = this[0];

    $(document).click(function(ev){
        if(ev.target !== el){
            $(el).remove()
        }
    })

    $(el).show();
    return this;
 })
</code></pre>

<p>To use it, you&#8217;d add the element to be displayed to the page, and then call tooltip on it like:</p>

<pre><code>$("&lt;div class='tooltip'&gt;Some Info&lt;/div&gt;")
        .appendTo(document.body)
        .tooltip()
</code></pre>

<p>But, this code has a problem.  Can you spot it?  Here&#8217;s a hint. What if your application is long lived and lots of these tooltip elements are created?</p>

<p>The problem is this code leaks memory!  Every tooltip element, and any tooltip child elements, are kept in memory forever.  This is because the click handler is not removed from the document and has a closure reference to the element.</p>

<p>This is a frighteningly easy mistake to make.  jQuery removes all event handlers from elements that are removed from the page so developers often don&#8217;t have to worry about unbinding event handlers.  But in this case, we bound to something outside the widget&#8217;s element, the document, and did not unbind the event handler.</p>

<p>But within a Model-View-Controller architecture, Controllers listen to the View and Views listen to the Model.  You are constantly listening to events outside the widget&#8217;s element.  For example, the <code>nextPrev</code> widget from the <code>$.Model</code> section listens to updates in the paginate model:</p>

<pre><code>paginate.bind('updated.attr', function(){
    self.find('.prev')[this.canPrev() ? 'addClass' : 'removeClass']('enabled')
    self.find('.next')[this.canNext() ? 'addClass' : 'removeClass']('enabled');
})
</code></pre>

<p>But, it doesn&#8217;t unbind from paginate!  Forgetting to remove event handlers is potentially a source of errors.  However, both the tooltip and nextPrev would not error.  Instead both will silently kill an application&#8217;s performance.  Fortunately, $.Controller makes this <strong>easy</strong> and <strong>organized</strong>.  We can write tooltip like:</p>

<pre><code>$.Controller('Tooltip',{
    init: function(){
        this.element.show()
    },
    "{document} click": function(el, ev){
        if(ev.target !== this.element[0]){
            this.element.remove()
        }
    }
})
</code></pre>

<p>When the document is clicked and the element is removed from the DOM, $.Controller will automatically unbind the document click handler.</p>

<p>$.Controller can do the same thing for the nextPrev widget binding to the the paginate model:</p>

<pre><code>$.Controller('Nextprev',{
    ".next click" : function(){
        var paginate = this.options.paginate;
        paginate.attr('offset', paginate.offset+paginate.limit);
    },
    ".prev click" : function(){
        var paginate = this.options.paginate;
        paginate.attr('offset', paginate.offset-paginate.limit );
    },
    "{paginate} updated.attr" : function(ev, paginate){
        this.find('.prev')[paginate.canPrev() ? 'addClass' : 'removeClass']('enabled')
        this.find('.next')[paginate.canNext() ? 'addClass' : 'removeClass']('enabled');
    }
})

// create a nextprev control
$('#pagebuttons').nextprev({ paginate: new Paginate() })
</code></pre>

<p>If the element <code>#pagebuttons</code> is removed from the page, the Nextprev controller instance will automatically unbind from the paginate model.</p>

<p>Now that your appetite for error free code is properly whetted, the following details how $.Controller works.</p>

<h3>Overview</h3>

<p>$.Controller inherits from $.Class.  To create a Controller class, call <code>$.Controller( NAME, classProperties, instanceProperties )</code> with the name of your controller, static methods, and instance methods.  The following is the start of a reusable list widget:</p>

<pre><code>$.Controller("List", {
    defaults : {}
},{
    init : function(){  },
        "li click" : function(){  }
})
</code></pre>

<p>When a controller class is created, it creates a jQuery helper method of a similar name.  The helper method is primarily use to create new instances of controller on elements in the page.  The helper method name is the controller&#8217;s name underscored, with any periods replaced with underscores.  For example, the helper for <code>$.Controller('App.FooBar')</code> is <code>$(el).app_foo_bar()</code>.</p>

<h3>Controller Instantiation</h3>

<p>To create a controller instance, you can call <code>new Controller(element, options)</code> with a HTMLElment or jQuery-wrapped element and an optional options object to configure the controller.  For example:</p>

<pre><code>new List($('ul#tasks'), {model : Task});
</code></pre>

<p>You can also use the jQuery helper method to create a List controller instance on the <code>#tasks</code> element like:</p>

<pre><code>$('ul#tasks').list({model : Task})
</code></pre>

<p>When a controller is created, it calls the controller&#8217;s prototype init method with:</p>

<ul>
<li><code>this.element</code> set to the jQuery-wrapped HTML element</li>
<li><code>this.options</code> set to the options passed to the controller merged with the class&#8217;s <code>defaults</code> object.</li>
</ul>


<p>The following updates the List controller to request tasks from the model and render them with an optional template passed to the list:</p>

<pre><code>$.Controller("List", {
    defaults : {
        template: "items.ejs"
    }
},{
    init : function(){
        this.element.html( this.options.template, this.options.model.findAll() ); 
    },
    "li click" : function(){  }
})
</code></pre>

<p>We can now configure Lists to render tasks with a template we provide.  How flexible!</p>

<pre><code>$('#tasks').list({model: Task, template: "tasks.ejs"});
$('#users').list({model: User, template: "users.ejs"})
</code></pre>

<p>If we don&#8217;t provide a template, List will default to using items.ejs.</p>

<h3>Event Binding</h3>

<p>As mentioned in $.Controller&#8217;s introduction, it&#8217;s most powerful feature is it&#8217;s ability to bind and unbind event handlers.</p>

<p>When a controller is created, it looks for action methods.  Action methods are methods that look like event handlers.  For example, <code>"li click"</code>.  These actions are bound using <code>jQuery.bind</code> or <code>jQuery.delegate</code>.  When the controller is destroyed, by removing the controller&#8217;s element from the page or calling destroy on the controller, these events are unbound, preventing memory leaks.</p>

<p>The following are examples of actions with descriptions of what the listen for:</p>

<ul>
<li><code>"li click"</code> - clicks on or within <code>li</code> elements within the controller element.</li>
<li><code>"mousemove"</code> - mousemoves within the controller element.</li>
<li><code>"{window} click"</code> - clicks on or within the window.</li>
</ul>


<p>Action functions get called back with the jQuery-wrapped element or object that the event happened on and the event.  For example:</p>

<pre><code>"li click": function( el, ev ) {
    assertEqual(el[0].nodeName, "li" )
        assertEqual(ev.type, "click")
}
</code></pre>

<h3>Templated Actions</h3>

<p>$.Controller supports templated actions.  Templated actions can be used to bind to other objects, customize the event type, or customize the selector.</p>

<p>Controller replaces the parts of your actions that look like <code>{OPTION}</code> with a value in the controller&#8217;s options or the window.</p>

<p>The following is a skeleton of a menu that lets you customize the menu to show sub-menus on different events:</p>

<pre><code>$.Controller("Menu",{
    "li {openEvent}" : function(){
    // show subchildren
    }
});

//create a menu that shows children on click
$("#clickMenu").menu({openEvent: 'click'});

//create a menu that shows children on mouseenter
$("#hoverMenu").menu({openEvent: 'mouseenter'});
</code></pre>

<p>We could enhance the menu further to allow customization of the menu element tag:</p>

<pre><code>$.Controller("Menu",{
    defaults : {menuTag : "li"}
},{
    "{menuTag} {openEvent}" : function(){
    // show subchildren
    }
});

$("#divMenu").menu({menuTag : "div"})
</code></pre>

<p>Templated actions let you bind to elements or objects outside the controller&#8217;s element.  For example, the Task model from the $.Model section produces a &#8220;created&#8221; event when a new Task is created.  We can make our list widget listen to tasks being created and automatically add these tasks to the list like:</p>

<pre><code>$.Controller("List", {
    defaults : {
        template: "items.ejs"
    }
},{
    init : function(){
        this.element.html( this.options.template, this.options.model.findAll() ); 
    },
    "{Task} created" : function(Task, ev, newTask){
        this.element.append(this.options.template, [newTask])
    }
})
</code></pre>

<p>The <code>"{Task} create"</code> gets called with the Task model, the created event, and the newly created Task. The function uses the template to render a list of tasks (in this case there is only one) and add the resulting html to the element.</p>

<p>But, it&#8217;s much better to make List work with any model.  Instead of hard coding tasks, we&#8217;ll make controller take a model as an option:</p>

<pre><code>$.Controller("List", {
    defaults : {
        template: "items.ejs",
        model: null
    }
},{
    init : function(){
        this.element.html( this.options.template, this.options.model.findAll() ); 
    },
    "{model} created" : function(Model, ev, newItem){
        this.element.append(this.options.template, [newItem])
    }
})
// create a list of tasks
$('#tasks').list({model: Task, template: "tasks.ejs"});
</code></pre>

<h2>Putting it all together - an abstract CRUD list.</h2>

<p>Now we will enhance the list to not only add items when they are created, but update them and remove them when they are destroyed.  To do this, we start by listening to updated and destroyed:</p>

<pre><code>"{model} updated" : function(Model, ev, updatedItem){
    // find and update the LI for updatedItem
},
"{model} destroyed" : function(Model, ev, destroyedItem){
    // find and remove the LI for destroyedItem
}
</code></pre>

<p>You&#8217;ll notice here we have a problem.  Somehow, we need to find the element that represents particular model instance.  To do this, we need to label the element as belonging to the model instance.  Fortunately, $.Model and $.View make labeling an element with an instance and finding that element very easy.</p>

<p>To label the element with a model instance within an EJS view, you simply write the model instance to the element.  The following might be <code>tasks.ejs</code></p>

<pre><code>&lt;% for(var i =0 ; i &lt; this.length; i++){ %&gt;
&lt;% var task = this[i]; %&gt;
    &lt;li &lt;%= task %&gt; &gt; &lt;%= task.name %&gt; &lt;/li&gt;
&lt;% } %&gt;
</code></pre>

<p><code>tasks.ejs</code> iterates through a list of tasks.  For each task, it creates an <code>li</code> element with the task&#8217;s name.  But, it also adds the task to the element&#8217;s jQuery data with: <code>&lt;li &lt;%= task %&gt; &gt;</code>.</p>

<p>To later get that element given a model instance, you can call <code>modelInstance.elements([CONTEXT])</code>.  This returns the jQuery-wrapped elements the represent the model instance.</p>

<p>Putting it together, list becomes:</p>

<pre><code>$.Controller("List", {
    defaults : {
        template: "items.ejs",
        model: null
    }
},{
    init : function(){
        this.element.html( this.options.template, this.options.model.findAll() ); 
    },
    "{model} created" : function(Model, ev, newItem){
        this.element.append(this.options.template, [newItem])
    },
    "{model} updated" : function(Model, ev, updatedItem){
        updatedItem.elements(this.element)
        .replaceWith(this.options.template, [updatedItem])
    },
    "{model} destroyed" : function(Model, ev, destroyedItem){
        destroyedItem.elements(this.element)
         .remove()
    }
});

// create a list of tasks
$('#tasks').list({model: Task, template: "tasks.ejs"});
</code></pre>

<p>It&#8217;s almost frighteningly easy to create abstract, reusable, memory safe widgets with JavaScriptMVC.</p>

<h3>Determinism</h3>

<p>Controllers provide automatic determinism for your widgets.  This means you can look at a controller and know where in the DOM they operate, and vice versa.</p>

<p>First, when a controller is created, it adds its underscored name as a class name on the parent element.</p>

<pre><code>&lt;div id='historytab' class='history_tabs'&gt;&lt;/div&gt;
</code></pre>

<p>You can look through the DOM, see a class name, and go find the corresponding controller.</p>

<p>Second, the controller saves a reference to the parent element in this.element.  On the other side, the element saves a reference to the controller instance in jQuery.data.</p>

<pre><code>$("#foo").data('controllers')
</code></pre>

<p>A helper method called controller (or controllers) using the jQuery.data reference to quickly look up controller instance on any element.</p>

<pre><code>$("#foo").controller() // returns first controller found
$("#foo").controllers() // returns an array of all controllers on this element
</code></pre>

<p>Finally, actions are self labeling, meaning if you look at a method called &#8220;.foo click&#8221;, there is no ambiguity about what is going on in that method.</p>

<h3>Responding to Actions</h3>

<p>If you name an event with the pattern &#8220;selector action&#8221;, controllers will set these methods up as event handlers with event delegation.  Even better, these event handlers will automatically be removed when the controller is destroyed.</p>

<pre><code>".todo mouseover" : function( el, ev ) {}
</code></pre>

<p>The el passed as the first argument is the target of the event, and ev is the jQuery event.  Each handler is called with &#8220;this&#8221; set to the controller instance, which you can use to save state.</p>

<h3>Removing Controllers</h3>

<pre><code>Part of the magic of controllers is their automatic removal and cleanup.  Controllers bind to the special destroy event, which is triggered whenever an element is removed via jQuery.  So if you remove an element that contains a controller with el.remove() or a similar method, the controller will remove itself also.  All events bound in the controller will automatically clean themselves up.
</code></pre>

<h3>Defaults</h3>

<pre><code>Controllers can be given a set of default options.  Users creating a controller pass in a set of options, which will overwrite the defaults if provided.

In this example, a default message is provided, but can is overridden in the second example by "hi".

$.Controller("Message", {
    defaults : {
        message : "Hello World"
    }
},{
    init : function(){
        this.element.text(this.options.message);
    }
})

$("#el1").message(); //writes "Hello World"
$("#el12").message({message: "hi"}); //writes "hi"
</code></pre>

<h3>Parameterized Actions</h3>

<p>Controllers provide the ability to set either the selector or action of any event via a customizable option.  This makes controllers potentially very flexible.  You can create more general purpose event handlers and instantiate them for different situations.</p>

<p>The following listens to li click for the controller on #clickMe, and &#8220;div mouseenter&#8221; for the controller on #touchMe.</p>

<pre><code>$.Controller("Hello", {
    defaults: {item: “li”, helloEvent: “click”}
}, {
    “{item} {helloEvent}" : function(el, ev){
        alert('hello')  el // li, div
    }
})

$("#clickMe").hello({item: “li”, helloEvent : "click"});
$("#touchMe").hello({item: “div”, helloEvent : "mouseenter"});
</code></pre>

<h3>Pub / Sub</h3>

<p>JavaScriptMVC applications often use OpenAjax event publish and subscribe as a good way to globally notify other application components of some interesting event.  The jquery/controller/subscribe method lets you subscribe to (or publish) OpenAjax.hub messages:</p>

<pre><code>$.Controller("Listener",{
    "something.updated subscribe" : function(called, data){}
})

// called elsewhere
this.publish("some.event", data);
</code></pre>

<h3>Special Events</h3>

<p>Controllers provide support for many types of special events.  Any event that is added to jQuery.event.special and supports bubbling can be listened for in the same way as a DOM event like click.</p>

<pre><code>$.Controller("MyHistory",{
    "history.pagename subscribe" : function(called, data){
        //called when hash = #pagename
    }
})
</code></pre>

<p>Drag, drop, hover, and history and some of the more widely used controller events.  These events will be discussed later.</p>

<p>controller is created, it adds its underscored name as a class name on the parent element.</p>

<pre><code>&lt;div id='historytab' class='history_tabs'&gt;&lt;/div&gt;
</code></pre>

<p>You can look through the DOM, see a class name, and go find the corresponding controller.</p>

<p>Second, the controller saves a reference to the parent element in this.element.  On the other side, the element saves a reference to the controller instance in jQuery.data.</p>

<pre><code>$("#foo").data('controllers')
</code></pre>

<p>A helper method called controller (or controllers) using the jQuery.data reference to quickly look up controller instance on any element.</p>

<pre><code>$("#foo").controller() // returns first controller found
$("#foo").controllers() // returns an array of all controllers on this element
</code></pre>

<p>Finally, actions are self labeling, meaning if you look at a method called &#8220;.foo click&#8221;, there is no ambiguity about what is going on in that method.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-02-07T09:39:00+08:00" pubdate data-updated="true">Feb 7<span>th</span>, 2012</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/javascriptmvc/'>javascriptMVC</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2012/02/06/jquery-layout-cross-slick-grid/">
		
			[jQuery]UI.layout*SlickGrid - 使SlickGrid在layout改變大小時能自動filter高度</a>
	</h2>
	<div class="entry-content">
		<p>目前只有一種作法，利用publish/subscribe告訴SlickGrid要去追parent的高度</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">&quot;units/set_grid_height&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">new_height</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">grid_opts</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">new_height</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">resize</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// grid = the jQuery element that represents the SlickGrid</span>
</span><span class='line'><span class="c1">// slick = the instantiated slickgrid</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">resize</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">grid</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">grid_opts</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">slick</span><span class="p">.</span><span class="nx">resizeCanvas</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">layout</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">).</span><span class="nx">layout</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">center</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">onresize</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">el</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">layout_name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">$</span><span class="p">.</span><span class="nx">publish</span><span class="p">(</span><span class="s2">&quot;units/set_grid_height&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nx">state</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">]);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">publish</span><span class="p">(</span><span class="s2">&quot;units/set_grid_height&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nx">layout</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">center</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>




		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-02-06T13:42:00+08:00" pubdate data-updated="true">Feb 6<span>th</span>, 2012</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/jquery/'>jquery</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2012/02/06/jquery-layout-cross-tabs/">
		
			[Jquery] jQuery Layout X jQuery UI Tabs的應用</a>
	</h2>
	<div class="entry-content">
		<p>jQuery layout是一套幫助RD排版的工具，
現在遇到一個需求是在某個layout出來的版面中塞jQuery UI TABS，
會有scrollbar顯示的問題。</p>

<p>在jQuery layout官方範例有特別作一個tab結合的範例，看看它怎麼處理這個問題：
<a href="http://layout.jquery-dev.net/demos/tabs.html">原始網址</a></p>

<h2>jsfiddle</h2>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/tmmuU/embedded/js,resources,html,css,result/light/"></iframe>


<h2>source</h2>

<figure class='code'><figcaption><span>jquery.layout-latest.js</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="mi">322</span>             <span class="p">,</span>   <span class="nx">contentSelector</span><span class="o">:</span>        <span class="s2">&quot;.ui-layout-content&quot;</span> <span class="c1">// INNER div/element to auto-size so only it scrolls, not the entire pane!                      </span>
</span><span class='line'><span class="mi">323</span>         <span class="p">,</span>   <span class="nx">contentIgnoreSelector</span><span class="o">:</span>  <span class="s2">&quot;.ui-layout-ignore&quot;</span> <span class="c1">// element(s) to &#39;ignore&#39; when measuring &#39;content&#39;</span>
</span><span class='line'><span class="mi">324</span>         <span class="p">,</span>   <span class="nx">findNestedContent</span><span class="o">:</span>      <span class="kc">false</span>       <span class="c1">// true = $P.find(contentSelector), false = $P.children(contentSelector)</span>
</span><span class='line'><span class="mi">325</span>         <span class="c1">//  GENERIC ROOT-CLASSES - for auto-generated classNames</span>
</span><span class='line'><span class="mi">326</span>         <span class="p">,</span>   <span class="nx">paneClass</span><span class="o">:</span>              <span class="s2">&quot;ui-layout-pane&quot;</span>    <span class="c1">// border-Pane - default: &#39;ui-layout-pane&#39;</span>
</span><span class='line'><span class="mi">327</span>         <span class="p">,</span>   <span class="nx">resizerClass</span><span class="o">:</span>           <span class="s2">&quot;ui-layout-resizer&quot;</span> <span class="c1">// Resizer Bar      - default: &#39;ui-layout-resizer&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是，利用<code>contentSelector</code>跟<code>findNestedContent</code>告訴layout plugin我要把contentSelector的內容視作layout-pane的本體，
在改變大小時候應該去改變它而不是整個layout-pane。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-02-06T10:05:00+08:00" pubdate data-updated="true">Feb 6<span>th</span>, 2012</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/jquery/'>jquery</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2012/02/03/fixture/">
		
			[jQuery] $.fixture介紹：模擬ajax Request Callback</a>
	</h2>
	<div class="entry-content">
		<p>$.fixture可以攔截ajax請求並且模擬可能的回應，回應可以從一個檔案(json格式)或某個callback函式。
這對你在開發js而不想依賴後端回應的時候很有用。</p>

<h2>Fixture的型態</h2>

<p>Fixtrue有兩種常見的使用方式，第一個是使用靜態檔案回應ajax請求。
下面這個敘述會攔截對<code>tasks.json</code>的請求，將它導向<code>fixtures/tasks.json</code>這個檔案的內容：</p>

<pre><code>$.fixture("/tasks.json","fixtures/tasks.json");
</code></pre>

<p>另一個選擇是使用函式動態產生回應資料。下面的敘述攔截對<code>tasks/ID.json</code>的更新請求，並且回應被更新的資料(事實上沒有更新到伺服端):</p>

<pre><code>$.fixture("PUT /tasks/{id}.json", function(original, settings, headers){
    return { updatedAt : new Date().getTime() }
})
</code></pre>

<p>我們將fixture分為兩種型態:
* 靜態fixture - 用檔案內容回應。
* 動態fixture - 用函式產生的資料回應。</p>

<p>這兩種不同型態各有一些方法去使用它們。</p>

<h2>靜態Fixture</h2>

<p>靜態fixture使用一個替代URL來回應ajax請求，如下：</p>

<pre><code>// 使用相對位置
$.fixture("tasks/1", "fixtures/task1.json");

// 使用絕對位置
$.fixture("tasks/1", "//fixtures/task1.json");
</code></pre>

<h2>動態Fixtures</h2>

<p>動態fixture實際上就是一個函式。它可以拿到你對ajax請求給予的參數並且回給你假的回應。</p>

<p>例如，下面會回應一個成功的請求，資料則是JSON格式。</p>

<pre><code>$.fixture("/foobar.json", function(orig, settings, headers){
    return [200, "success", {json: {foo: "bar" } }, {} ]
})
</code></pre>

<p>fixture函數的signature如下</p>

<pre><code>function( originalOptions, options, headers ) {
    return [ status, statusText, responses, responseHeaders ]
}
</code></pre>

<p>呼叫參數的意義如下：</p>

<ul>
<li>originalOptions - are the options provided to the ajax method, unmodified, and thus, without defaults from ajaxSettings</li>
<li>options - are the request options</li>
<li>headers - a map of key/value request headers</li>
</ul>


<p>and the fixture function returns an array as arguments for ajaxTransport&#8217;s completeCallback with:</p>

<ul>
<li>status - is the HTTP status code of the response.</li>
<li>statusText - the status text of the response</li>
<li>responses - a map of dataType/value that contains the responses for each data format supported</li>
<li>headers - response headers</li>
</ul>


<p>However, $.fixture handles the common case where you want a successful response with JSON data. The previous can be written like:</p>

<pre><code>$.fixture("/foobar.json", function(orig, settings, headers){
    return {foo: "bar" };
})
</code></pre>

<p>If you want to return an array of data, wrap your array in another array:</p>

<pre><code>$.fixture("/tasks.json", function(orig, settings, headers){
    return [ [ "first","second","third"] ];
})
</code></pre>

<p>$.fixture works closesly with jQuery&#8217;s ajaxTransport system. Understanding it is the key to creating advanced fixtures.</p>

<h2>Templated Urls</h2>

<p>Often, you want a dynamic fixture to handle urls for multiple resources (for example a REST url scheme). $.fixture&#8217;s templated urls allow you to match urls with a wildcard.</p>

<p>The following example simulates services that get and update 100 todos.</p>

<pre><code>// create todos
var todos = {};
for(var i = 0; i &lt; 100; i++) {
    todos[i] = {
        id: i,
        name: "Todo "+i
    }
}
$.fixture("GET /todos/{id}", function(orig){
    // return the JSON data
    // notice that id is pulled from the url and added to data
    return todos[orig.data.id]
})
$.fixture("PUT /todos/{id}", function(orig){
    // update the todo's data
    $.extend( todos[orig.data.id], orig.data );

    // return data
    return {};
})
</code></pre>

<p>Notice that data found in templated urls (ex: {id}) is added to the original data object.</p>

<h2>Simulating Errors</h2>

<p>The following simulates an unauthorized request to /foo.</p>

<pre><code>$.fixture("/foo", function(){
    return [401,"{type: 'unauthorized'}"]
});
</code></pre>

<p>This could be received by the following Ajax request:</p>

<pre><code>$.ajax({
    url: '/foo',
    error : function(jqXhr, status, statusText){
        // status === 'error'
        // statusText === "{type: 'unauthorized'}"
    }
})
</code></pre>

<h2>Turning off Fixtures</h2>

<p>You can remove a fixture by passing null for the fixture option:</p>

<pre><code>// add a fixture
$.fixture("GET todos.json","//fixtures/todos.json");

// remove the fixture
$.fixture("GET todos.json", null)
</code></pre>

<p>You can also set <code>jQuery.fixture.on</code> to false:</p>

<pre><code>$.fixture.on = false;
</code></pre>

<h2>Make</h2>

<p>$.fixture.make makes a CRUD service layer that handles sorting, grouping, filtering and more.</p>

<h2>Testing Performance</h2>

<p>Dynamic fixtures are awesome for performance testing. Want to see what 10000 files does to your app&#8217;s performance? Make a fixture that returns 10000 items.</p>

<p>What to see what the app feels like when a request takes 5 seconds to return? Set <code>jQuery.fixture.delay</code> to 5000.&#8217;</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-02-03T11:11:00+08:00" pubdate data-updated="true">Feb 3<span>rd</span>, 2012</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/jquery/'>jquery</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2012/02/02/jmvc-model/">
		
			[javascriptMVC] <翻譯+心得> Jmvc導覽(2) - $.Model</a>
	</h2>
	<div class="entry-content">
		<h2>Model</h2>

<p>javascriptMVC的model和相關連plugin提供許多組織model資料的工具如驗證(validation)，關聯(association)，列表(list)還有其他更多。但核心功能專注在service encapsulation(服務包裝)，型態轉換(type converstion)，還有事件關聯(event)上。</p>

<pre><code>可以這麼說：沒有跟伺服器溝通的必要就不需用到model。
相反地請將所有跟伺服器資料交換的動作交給model用一致的介面來處理。
</code></pre>

<h3>屬性和觀察可能性 - Attributes and Observables</h3>

<p>model層一個絕對的重要性在於存取物件資料的屬性(property), 和監聽model個體的改變。這就是觀察者模式而且正是MVC的重要環節 - view監聽model的改變。</p>

<p>幸運的是，JavascriptMVC使得任何資料都可以容易的被觀察(obsevable)。一個好的例子是翻頁機制。一個頁面通常有許多的翻譯控制項，例如，一個控制項提供前一頁另一個提供後一頁。另一個控制項可能提供顯示這一頁的部份資料（例如顯示1-20項）。所有的頁面控制項會需要同樣的資料：</p>

<ul>
<li>offset - 要顯示的第一個項目的位置</li>
<li>limit - 總共要顯示多少項目</li>
<li>count - 全部項目的數量</li>
</ul>


<p>We can model this data with JavaScriptMVC&#8217;s $.Model like:</p>

<pre><code>var paginate = new $.Model({
    offset: 0,
    limit: 20,
    count: 200
});
</code></pre>

<p>The paginate variable is now observable.  We can pass it to pagination controls that can read from, write to, and listen for property changes.  You can read properties like normal or using the <code>model.attr(NAME)</code> method:</p>

<pre><code>assertEqual( paginate.offset, 0 );
assertEqual( paginate.attr('limit') , 20 );
</code></pre>

<p>If we clicked the next button, we need to increment the offset.  Change property values with <code>model.attr(NAME, VALUE)</code>.  The following moves the offset to the next page:</p>

<pre><code>paginate.attr('offset',20);  
</code></pre>

<p>When paginate&#8217;s state is changed by one control, the other controls need to be notified.  You can bind to a specific attribute change with <code>model.bind(ATTR, success( ev, newVal ) )</code> and update the control:</p>

<pre><code>paginate.bind('offset', function(ev, newVal){
    $('#details').text( 'Showing items ' + (newVal+1 )+ '-' + this.count )
})
</code></pre>

<p>You can also listen to any attribute change by binding to the <code>'updated.attr'</code> event:</p>

<pre><code>paginate.bind('updated.attr', function(ev, newVal){
    $('#details').text( 'Showing items ' + (newVal+1 )+ '-' + this.count )
})
</code></pre>

<p>The following is a next-previous jQuery plugin that accepts paginate data:</p>

<pre><code>$.fn.nextPrev = function(paginate){
    this.delegate('.next','click', function(){
        var nextOffset = paginate.offset+paginate.limit;
        if( nextOffset &lt; paginate.count){
            paginate.attr('offset', nextOffset );
        }
    })
    this.delegate('.prev','click', function(){
        var nextOffset = paginate.offset-paginate.limit;
        if( 0 &lt; paginate.offset ){
            paginate.attr('offset', Math.max(0, nextOffset) );
        }
    });
    var self = this;
    paginate.bind('updated.attr', function(){
        var next = self.find('.next'),
        prev = self.find('.prev');
        if( this.offset == 0 ){
            prev.removeClass('enabled');
        } else { 
            prev.removeClass('disabled');
        }
        if( this.offset &gt; this.count - this.limit ){
            next.removeClass('enabled');
        } else { 
            next.removeClass('disabled');
        }
    })
};
</code></pre>

<p>There are a few problems with this plugin. First, if the control is removed from the page, it is not unbinding itself from paginate.  We&#8217;ll address this when we discuss controllers.</p>

<p>Second, the logic protecting a negative offset or offset above the total count is done in the plugin.  This logic should be done in the model. To fix this problem, we&#8217;ll need to add additional constraints to limit what values limit, offset, and count can be.  We&#8217;ll need to create a pagination class.</p>

<h3>Extending Model</h3>

<p>JavaScriptMVC&#8217;s model inherits from $.Class.  Thus, you create a model class by inheriting from <code>$.Model(NAME, [STATIC,] PROTOTYPE)</code>:</p>

<pre><code>$.Model('Paginate',{
    staticProperty: 'foo'
},{
    prototypeProperty: 'bar'
})
</code></pre>

<p>There are a few ways to make the Paginate model more useful.  First, by adding setter methods, we can limit what values count and offset can be set to.</p>

<h3>Setters</h3>

<p>Settter methods are model prototype methods that are named <code>setNAME</code>.  They get called with the val passed to <code>model.attr(NAME, val)</code> and a success and error callback.  Typically, the method should return the value that should be set on the model instance or call error with an error message.  Success is used for asynchronous setters.</p>

<p>The following paginate model uses setters to prevent negative counts the offset from exceeding the count by adding <code>setCount</code> and <codE>setOffset</code> instance methods.</p>

<pre><code>$.Model('Paginate',{
    setCount : function(newCount, success, error){
        return newCount &lt; 0 ? 0 : newCount;
    },
    setOffset : function(newOffset, success, error){
        return newOffset &lt; 0 ? 0 : Math.min(newOffset, !isNaN(this.count - 1) ? this.count : Infinity )
    }
})
</code></pre>

<p>Now the nextPrev plugin can set offset with reckless abandon:</p>

<pre><code>this.delegate('.next','click', function(){
    paginate.attr('offset', paginate.offset+paginate.limit);
})
this.delegate('.prev','click', function(){
    paginate.attr('offset', paginate.offset-paginate.limit );
});
</code></pre>

<h3>Defaults</h3>

<p>We can add default values to Paginate instances by setting the static <code>defaults</code> property.  When a new paginate instance is created, if no value is provided, it initializes with the default value.</p>

<pre><code>$.Model('Paginate',{
    defaults : {
        count: Infinity,
        offset: 0,
        limit: 100
    }
},{
    setCount : function(newCount, success, error){ ... },
    setOffset : function(newOffset, success, error){ ... }
})

var paginate = new Paginate({count: 500});
assertEqual(paginate.limit, 100);
assertEqual(paginate.count, 500);
</code></pre>

<p>This is getting sexy, but the Paginate model can make it even easier to move to the next and previous page and know if it&#8217;s possible by adding helper methods.</p>

<h3>Helper methods</h3>

<p>Helper methods are prototype methods that help set or get useful data on model instances.  The following, completed, Paginate model includes a <code>next</code> and <code>prev</code> method that will move to the next and previous page if possible.  It also provides a <code>canNext</code> and <code>canPrev</code> method that returns if the instance can move to the next page or not.</p>

<pre><code>$.Model('Paginate',{
    defaults : {
        count: Infinity,
        offset: 0,
        limit: 100
    }
},{
    setCount : function( newCount ){
        return Math.max(0, newCount  );
    },
    setOffset : function( newOffset ){
        return Math.max( 0 , Math.min(newOffset, this.count ) )
    },
    next : function(){
        this.attr('offset', this.offset+this.limit);
    },
    prev : function(){
        this.attr('offset', this.offset - this.limit )
    },
    canNext : function(){
        return this.offset &gt; this.count - this.limit
    },
    canPrev : function(){
        return this.offset &gt; 0
    }
})
</code></pre>

<p>Thus, our jQuery widget becomes much more refined:</p>

<pre><code>$.fn.nextPrev = function(paginate){
    this.delegate('.next','click', function(){
        paginate.attr('offset', paginate.offset+paginate.limit);
    })
    this.delegate('.prev','click', function(){
        paginate.attr('offset', paginate.offset-paginate.limit );
    });
    var self = this;
    paginate.bind('updated.attr', function(){
        self.find('.prev')[paginate.canPrev() ? 'addClass' : 'removeClass']('enabled')
        self.find('.next')[paginate.canNext() ? 'addClass' : 'removeClass']('enabled');
    })
};
</code></pre>

<h3>Service Encapsulation</h3>

<p>We&#8217;ve just seen how $.Model is useful for modeling client side state.  However, for most applications, the critical data is on the server, not on the client.  The client needs to create, retrieve, update and delete (CRUD) data on the server.  Maintaining the duality of data on the client and server is tricky business.   $.Model is used to simplify this problem.</p>

<p>$.Model is extremely flexible.  It can be made to work with all sorts of services types and data types.  This book covers only how $.Model works with the most common and popular type of service and data type: Representational State Transfer (REST) and JSON.</p>

<p>A REST service uses urls and the HTTP verbs POST, GET, PUT, DELETE to create, retrieve, update, and delete data respectively.  For example, a tasks service that allowed you to create, retrieve, update and delete tasks might look like:</p>

<table>
<tr>
<th>ACTION</th><th>VERB</th><th>URL</th><th>BODY</th><th>RESPONSE</th>
</tr>
<tr>
<td>Create a task</td><td>POST</td><td>/tasks</td><td>name=do the dishes</td><td><pre><code>{
    "id"       : 2,
        "name"     : "do the dishes",
        "acl"      : "rw" ,
        "createdAt": 1303173531164 // April 18 2011
}</code></pre></td>
</tr>
<tr>
<td>Get a task</td><td>GET</td><td>/task/2</td><td></td><td><pre><code>{
    "id"       : 2,
        "name"     : "do the dishes",
        "acl"      : "rw" ,
        "createdAt": 1303173531164 // April 18 2011
}</pre></code></td>
</tr>
<tr>
<td>Get tasks</td><td>GET</td><td>/tasks</td><td></td><td>
<pre><code>[{
    "id"       : 1,
        "name"     : "take out trash",
        "acl"      : "r",
        "createdAt": 1303000731164 // April 16 2011
},
{
    "id"       : 2,
    "name"     : "do the dishes",
    "acl"      : "rw" ,
    "createdAt": 1303173531164 // April 18 2011
}]</code>
</pre>
</td>
</tr>
<tr>
<td>Update a task</td><td>PUT</td><td>/task/2</td><td>name=take out recycling</td><td><pre><code>{
    "id"       : 2,
    "name"     : "take out recycling",
    "acl"      : "rw" ,
    "createdAt": 1303173531164 // April 18 2011
}</pre></code></td>
</tr>
<tr>
<td>Delete a task</td><td>DELETE</td><td>/task/2</td><td></td><td><pre><code>{}</pre></code></td>
</tr>
</table>


<p>TODO: We can label the urls</p>

<p>The following connects to task services, letting us create, retrieve, update and delete tasks from the server:</p>

<pre><code>$.Model("Task",{
    create  : "POST /tasks.json",
    findOne : "GET /tasks/{id}.json",
    findAll : "GET /tasks.json",
    update  : "PUT /tasks/{id}.json",
    destroy : "DELETE /tasks/{id}.json"
},{ });
</code></pre>

<p>The following table details how to use the task model to CRUD tasks.</p>

<table>
<tr>
<th>ACTION</th><th>CODE</th><th>DESCRIPTION</th>
</tr>
<tr>
<td>Create a task</td>
    <td><pre><code>new Task({ name: 'do the dishes'}).save( 
            success( task, data ), 
            error( jqXHR) 
            ) -> taskDeferred</code></pre></td>
    <td><p>To create an instance of a model on the server, first create an instance with <code>new Model(attributes)</code>.  Then call <code>save()</code>.</p>
    <p>Save checks if the task has an id.  In this case it does not so save makes a create request with the task&#8217;s attributes.  Save takes two parameters:</p>
    <ul>
    <li><code>success</code> - a function that gets called if the save is successful.  Success gets called with the <code>task</code> instance and the <code>data</code> returned by the server.</li>
    <li><code>error</code> - a function that gets called if there is an error with the request.  It gets called with jQuery&#8217;s wrapped XHR object.</li>
    </ul>

    Save returns a deferred that resolves to the created task.
    </td>
    </tr>
    <tr>
    <td>Get a task</td>
<td><pre><code>Task.findOne(params, 
        success( task ), 
        error( jqXHR) 
        ) -> taskDeferred</code></pre></td>
<td>Retrieves a single task from the server. It takes three parameters:
<ul>
<li><code>params</code> - data to pass to the server.  Typically an id like: <code>{id: 2}</code>.</li>
<li><code>success</code> - a function that gets called if the request is succesful.  Success gets called with the <code>task</code> instance.</li>
<li><code>error</code> - a function that gets called if there is an error with the request.</li>
</ul>

findOne returns a deferred that resolves to the task.
</td>
</tr>
<td>Get tasks</td>rst change the attributes of a model instance with  <code>attr</code>.  Then call <code>save()</code>.</p>
<p>Save takes the same arguments and returns the same deferred as the create task case.</p>
</td>
</tr>
<tr>
<td>Destroy a task</td>
    <td><pre><code>task.destroy( 
            success( task, data ), 
            error( jqXHR) 
            ) -> taskDeferred</code></pre></td>
    <td><p>Destroys a task on the server. Destroy takes two parameters:</p>
    <ul>
    <li><code>success</code> - a function that gets called if the save is successful.  Success gets called with the <code>task<code> instance and the <code>data</code> returned by the server.</li>
    <li><code>error</code> - a function that gets called if there is an error with the request.</li>
    </ul>

    Destroy returns a deferred that resolves to the destroyed task.
    </td>
    </tr>
    </table>


<pre><code>The &lt;code&gt;Task&lt;/code&gt; model has essentially become a contract to our services!
</code></pre>

<h3>Type Conversion</h3>

<p>Did you notice how the server responded with createdAt values as numbers like <code>1303173531164</code>.  This number is actually April 18th, 2011.  Instead of getting a number back from <code>task.createdAt</code>, it would be much more useful if it returns a JavaScript date created with <code>new Date(1303173531164)</code>.  We could do this with a <code>setCreatedAt</code> setter.  But, if we have lots of date types, this will quickly get repetitive.</p>

<p>To make this easy, $.Model lets you define the type of an attribute and a converter function for those types.  Set the type of attributes on the static <code>attributes</code> object and converter methods on the static <code>convert</code> object.</p>

<pre><code>$.Model('Task',{
    attributes : {
        createdAt : 'date'
    },
    convert : {
        date : function(date){
        return typeof date == 'number' ? new Date(date) : date;
        }
    }
},{});
</code></pre>

<p>Task now converts createdAt to a Date type.  To list the year of each task, write:</p>

<pre><code>Task.findAll({}, function(tasks){
    $.each(tasks, function(){
        console.log( "Year = "+this.createdAt.fullYear() )
    })
});
</code></pre>

<h3>CRUD Events</h3>

<p>Model publishes events when an instance has been created, updated, or destroyed. You can listen to these events globally on the Model or on an individual model instance. Use <code>MODEL.bind(EVENT, callback( ev, instance ) )</code> to listen for created, updated, or destroyed events.</p>

<p>Lets say we wanted to know when a task is created and add it to the page. After it&#8217;s been added to the page, we&#8217;ll listen for updates on that task to make sure we are showing its name correctly.  We can do that like:</p>

<pre><code>Task.bind('created', function(ev, task){
    var el = $('&lt;li&gt;').html(todo.name);
    el.appendTo($('#todos'));

    task.bind('updated', function(){
        el.html(this.name)
    }).bind('destroyed', function(){
        el.remove()
    })
})
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-02-02T11:18:00+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2012</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/javascriptmvc/'>javascriptmvc</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2012/02/02/jmvc-overview/">
		
			[JavascriptMVC] <翻譯+心得> JMVC導覽(1) Introduction + $.Class</a>
	</h2>
	<div class="entry-content">
		<h2>前言</h2>

<p>本文以<a href="https://gist.github.com/989117">https://gist.github.com/989117</a>
為基礎翻譯後再加上個人使用上的心得。</p>

<h2>介紹</h2>

<p>JavascriptMVC (JMVC)是一個基於jQuery的開放原始碼js框架。
它擁有完整的前端框架解決方案，包含打包工具，測試，代碼依賴管理，文件化，以及附帶許多有用的jQuery外掛。</p>

<p>JavascriptMVC的每一個項目都可以被獨立使用而不需要依賴其他項目。只看Class, Model, View, Controller部分的大小壓縮過只有7k左右，而且這之中的任何一個都還是能被獨立使用。
JavasriptMVC的輕巧及強大的獨立性使得它能應付複雜的大型web專案。</p>

<p>這個導覽 <strong>只會</strong> 提到JavaScriptMVC的$.Class, $.Model, $.View, 和$.Controller.  下列是它們各自的意義:</p>

<ul>
<li><code>$.Class</code> - 基於js的類別化系統</li>
<li><code>$.Model</code> - 傳統的model</li>
<li><code>$.View</code> - 客戶端模版系統</li>
<li><code>$.Controller</code> - jQuery元件工廠</li>
</ul>


<p>JavaScriptMVC的命名取向不像傳統的 <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#Concepts">Model-View-Controller</a> 設計模式. $.Controller被用來創造一個傳統的view，例如翻頁按鈕會列表，同時也是傳統的controller－－作為傳統的model與傳統的view之間協調的角色。</p>

<h2>安裝</h2>

<h3>方法一：官網下載</h3>

<p>JavaScriptMVC can be used as a single download that includes the entire framework.  But since this chapter covers only the MVC parts, go to the <a href="http://javascriptmvc.com/builder.html">download builder</a>, check Controller, Model, and View&#8217;s EJS templates and click download.</p>

<p>The download will come with minified and unminified versions of jQuery and the plugins you selected.  Load these with script tags in your page:</p>

<pre><code>&lt;script type='text/javascript' src='jquery-1.6.1.js'&gt;&lt;/script&gt;  
&lt;script type='text/javascript' src='jquerymx-1.0.custom.js'&gt;&lt;/script&gt; 
</code></pre>

<h3>方法二：github</h3>

<p>根據<a href="https://github.com/jupiterjs/javascriptmvc">JavascriptMVC on github</a>的README:</p>

<ol>
<li>在自己帳號內開一個新git專案取名jmvc</li>
<li><p>Fork 以下這些project到自己的github帳號內</p>

<p> http://github.com/jupiterjs/steal   <br/>
 http://github.com/jupiterjs/jquerymx<br/>
 http://github.com/jupiterjs/funcunit<br/>
 http://github.com/jupiterjs/documentjs</p>

<p>可選的額外功能</p>

<p> http://github.com/jupiterjs/mxui</p></li>
<li><p>在自己的電腦上取回剛剛fork的javascriptmvc</p>

<p> git submodule add git@github.com:<em>YOU</em>/steal.git steal
 git submodule add git@github.com:<em>YOU</em>/jquerymx.git jquery
 git submodule add git@github.com:<em>YOU</em>/funcunit.git funcunit
 git submodule add git@github.com:<em>YOU</em>/documentjs.git documentjs</p></li>
<li><p>因為作者將主要功能都模組化的緣故，有四個子模組需要手動取回</p>

<p> <div><script src='https://gist.github.com/1721116.js'></script>
<noscript><pre><code>git submodule add git@github.com:<em>YOU</em>/steal.git steal
git submodule add git@github.com:<em>YOU</em>/jquerymx.git jquery
git submodule add git@github.com:<em>YOU</em>/funcunit.git funcunit
git submodule add git@github.com:<em>YOU</em>/documentjs.git documentjs</code></pre></noscript></div></p></li>
<li><p>可以開始玩了！</p></li>
</ol>


<h2>Class</h2>

<p>JMVC的Controller和Model繼承自Class的helper - $.Class. 要創造一個類別，只要呼叫 <code>$.Class(NAME, [classProperties, ] instanceProperties])</code>.</p>

<pre><code>$.Class("Animal",{
    breathe : function(){
        console.log('breathe'); 
    }
});
</code></pre>

<p>在上例中，Animal的instance都有<code>breathe()</code>這個method. 我們可以建立一個新的<code>Animal</code> instance而且呼叫它的<code>breathe()</code>像這樣:</p>

<pre><code>var man = new Animal();
man.breathe();
</code></pre>

<p>如果你想要創造一個子類別, 只要把新類別名稱以及屬性用基礎類別呼叫即可:</p>

<pre><code>Animal("Dog",{
    wag : function(){
        console.log('wag');
    }
})

var dog = new Dog;
dog.wag();
dog.breathe();
</code></pre>

<h3>Instantiation - 物件化</h3>

<p>當一個新的物件物體被創造時, 它首先會執行這個類別的<code>init</code>函式, 將建構子帶的參數傳給init:</p>

<pre><code>$.Class('Person',{
    init : function(name){
        this.name = name;
    },
    speak : function(){
        return "I am "+this.name+".";
    }
});

var payal = new Person("Payal");
assertEqual( payal.speak() ,  'I am Payal.' );
</code></pre>

<h3>呼叫基礎類別函式(base method)</h3>

<p>用<code>this._super</code>使用基礎類別的函式.  下面重寫(overwrite)了person類別的speak函式。</p>

<pre><code>Person("ClassyPerson", {
    speak : function(){
        return "Salutations, "+this._super();
    }
});

var fancypants = new ClassyPerson("Mr. Fancy");
assertEquals( fancypants.speak() , 'Salutations, I am Mr. Fancy.')
</code></pre>

<h3>代理 - proxies</h3>

<p>Class的回呼函式會把this適當地設置(類似<a href="http://api.jquery.com/jQuery.proxy/">$.proxy</a>)。下面建立一個clicky類別然後計算它被click多少次。</p>

<pre><code>$.Class("Clicky",{
    init : function(){
        this.clickCount = 0;
    },
    clicked: function(){
        this.clickCount++;
    },
    listen: function(el){
        el.click( this.callback('clicked') );
    }
})

var clicky = new Clicky();
clicky.listen( $('#foo') );
clicky.listen( $('#bar') ) ;
</code></pre>

<h3>靜態繼承 - static inheritance</h3>

<p>Class可以定義靜態屬性跟類別。如下允許我們用<code>Person.findOne(ID, success(person) )</code>向伺服器端取得一個person個體。成功的話會回傳一個Person個體。</p>

<pre><code>$.Class("Person",{
    findOne : function(id, success){
        $.get('/person/'+id, function(attrs){
            success( new Person( attrs ) );
        },'json')
    }
},{
    init : function(attrs){
        $.extend(this, attrs)
    },
    speak : function(){
        return "I am "+this.name+".";
    }
})

Person.findOne(5, function(person){
    assertEqual( person.speak(), "I am Payal." );
})
</code></pre>

<h3>內觀 - Introspection</h3>

<p>Class提供命名空間以及存取類別名稱以及命名空間的物件:</p>

<pre><code>$.Class("Jupiter.Person");

Jupiter.Person.shortName; //-&gt; 'Person'
Jupiter.Person.fullName;  //-&gt; 'Jupiter.Person'
Jupiter.Person.namespace; //-&gt; Jupiter

var person = new Jupiter.Person();

person.Class.shortName; //-&gt; 'Person'
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2012-02-02T09:46:00+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2012</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/javascriptmvc/'>javascriptmvc</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/3/" class="prev">Prev</a>
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2013

    Alive Kuo

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ascheriit';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-29151691-2']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>