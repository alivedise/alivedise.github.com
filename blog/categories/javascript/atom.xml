<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Ascheriit]]></title>
  <link href="http://alivedise.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://alivedise.github.com/"/>
  <updated>2013-07-07T17:36:34+08:00</updated>
  <id>http://alivedise.github.com/</id>
  <author>
    <name><![CDATA[Alive Kuo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Window Management] Transition state machine]]></title>
    <link href="http://alivedise.github.com/blog/2013/07/05/transition-state-machine/"/>
    <updated>2013-07-05T14:53:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2013/07/05/transition-state-machine</id>
    <content type="html"><![CDATA[<p>The article is inspired by Tim's <a href="http://blog.timc.idv.tw/posts/css-classes-state-machine-puzzle/">CSS Classes State Machine Puzzle</a>.</p>

<p>We had some frustrations all the times, on animating a window correctly.</p>

<p>Recently I try to dedicate on solving the puzzle.
But at first I need to apologize for my poor knowledge and thought about css transitions using class names.</p>

<p>In the past I usually thought it was stupid to use class list to control the style.
I thought it was ambiguous and strange if we ran into a situation that there're more than one classes of same type put on one element. And an element full of different class names for different purposes may conflict. Recently I see <a href="https://github.com/h5bp/Effeckt.css">Effeckt</a> and know this is the trend: a simple class name stands for a kind of animation.</p>

<p>The real problem is that we should never put wrong class on the DOM element, in javascript. So this now turns to be a pure javascript puzzle.</p>

<p>We know, that, in certain moment, the app window is always in a specific state A, not B nor C. So what's the problem? It's how could we switch the state correctly.</p>

<p>Let's create a real state machine in javascript!</p>

<p>So far it doesn't take times for us to figure out that a window should have 4 basic transition state: <code>closed</code>, <code>opening</code>, <code>opened</code>, <code>closing</code>.</p>

<p>A basic transition life cycle of a window could be:</p>

<p><blockquote><p>(initial) -> closed -> opening -> opened ------> closing -> opening ------> ....</p></blockquote></p>

<p>Now we have 4 states, the next is what's the trigger to states switching?</p>

<p>In finite state machine, what triggers state change is named for <a href="https://en.wikipedia.org/wiki/Finite-state_machine">'event'</a>.</p>

<p>We know that at least we have 2 events: 'open' and 'close'.</p>

<ul>
<li>'open' would trigger <code>closed</code> switches to <code>opening</code></li>
<li>'close' would trigger <code>opened</code> switches to <code>closing</code></li>
<li>If we sends 'open' event into the state machine continously,
the second event would be ignored.
(Exactly it depends on what policy we choose. For example, we could devide 'opening' state into 'opening-part-1' and 'opening-part-2' states. And implement the async state change. But if we need s two-state opening, it sounds like a CSS design problem to me. Let's discuss this later if necessary.)</li>
<li>In order to gurantee the transition does really end and thus being independent from the 'animationend' event(The event here is HTML DOM Event), we need to add a timer between 'opening' and 'opened' state. Also between 'closing' and 'closed' state.</li>
<li>Let's call the new event 'timeout', the timing we set the timer is right after the transitioning from 'closed' to 'opening', and from 'opened' to 'closing' successfully occurs.</li>
<li>For some use case we may want to cancel the transition. The 'cancel' event is only valid in 'opening' and 'closing' state.</li>
</ul>


<p>So far, the state machine for transition we have:
<img src="http://i.imgur.com/MmBj2pY.jpg"></p>

<p>Now the problem is, how to represent this machine in javascript?</p>

<p>My anwser is put every transition relevant functions/attributes in another mixin object, which would be mixed into appWindow.prototype:</p>

<p>``` js
(function(window) {
  'use strict';</p>

<p>  function capitalize(string)
  {</p>

<pre><code>  return string.charAt(0).toUpperCase() + string.slice(1);
</code></pre>

<p>  };</p>

<p>  /<em>*
   * This object declares all transition event enum:
   *
   * * OPEN
   * * CLOSE
   * * FINISH
   * * END
   * * CANCEL
   *
   * @static
   * @namespace TransitionEvent
   * @type {Object}
   </em>/
  var EVT = {</p>

<pre><code>OPEN: 0,
CLOSE: 1,
FINISH: 2,
END: 3,
CANCEL: 4
</code></pre>

<p>  };</p>

<p>  var _EVTARRAY = ['OPEN', 'CLOSE', 'FINISH', 'END', 'CANCEL'];</p>

<p>  /<em>*
   * Describe the transition state table.
   *
   * @example
   * var toState = transitionTable[currentState][event];
   *
   * The value "null" indicates that the transition won't happen.
   *
   * @type {Object}
   </em>/
  var transitionTable = {</p>

<pre><code>          /* OPEN|CLOSE|FINISH|END|CANCEL */
'closed':  ['opening', null, null, null, null],
'opened':  [null, 'closing', null, null, null],
'closing': ['opened', null, 'closed', 'closed', 'opened'],
'opening': [null, 'closed', 'opened', 'opened', 'closed']
</code></pre>

<p>  };</p>

<p>  /<strong>
   * This provides methods and attributes used for transition state handling. It's not meant to
   * be used directly.
   *
   * The finite state machine of transition is working as(being from normal state):
   *
   * * <code>closed</code>  ---<em>event</em> </strong>OPEN<strong> ----------------> <code>opening</code>
   * * <code>opening</code> ---<em>event</em> </strong>END/FINISH/CANCEL<strong> ---> <code>opened</code>
   * * <code>opened</code>  ---<em>event</em> </strong>CLOSE<strong> ---------------> <code>closing</code>
   * * <code>closing</code> ---<em>event</em> </strong>END/FINISH/CANCEL<strong> ---> <code>closed</code>
   *
   * If you want to reuse this mixin in your object, you need to define these attributes: <code>this.element</code>
   *
   * And these method: <code>this.setVisible()</code> <code>this.publish()</code>
   *
   * The following callback functions are executed only when the transition state are successfully switched:
   * <code>_onOpen</code>
   * <code>_onClose</code>
   * <code>_onEnd</code>
   * <code>_onFinish</code>
   * <code>_onCancel</code>
   * <code>_leaveOpened</code>
   * <code>_enterOpened</code>
   * <code>_leaveClosed</code>
   * <code>_enterClosed</code>
   * <code>_leaveClosing</code>
   * <code>_enterClosing</code>
   * <code>_leaveOpening</code>
   * <code>_enterOpening</code>
   *
   * Every callback here is for internal usage and would be executed only once.
   *
   * However you could utilize inner event in other functions.
   *
   *
   * @mixin WindowTransition
   */
  /</strong>
   * @event AppWindow#<em>onTransitionOpen
   * @private
   * @memberof AppWindow
   */
  /**
   * @event AppWindow#</em>onTransitionClose
   * @private
   * @memberof AppWindow
   <em>/
  /**
   * @event AppWindow#_onTransitionEnd
   * @private
   * @memberof AppWindow
   </em>/
  /<strong>
   * @event AppWindow#_onTransitionFinish
   * @private
   * @memberof AppWindow
   */
  /</strong>
   * @event AppWindow#_onTransitionCancel
   * @private
   * @memberof AppWindow
   */</p>

<p>  var WindowTransition = {</p>

<pre><code>TRANSITION_EVENT: EVT,

/**
 * _transitionState indicates current transition state of appWindow.
 *
 * @memberOf WindowTransition
 * @default
 * @type {String}
 */
_transitionState: 'closed',

/**
 * Record the previous transition state.
 *
 * **Only updated if the state changes successfully.**
 * 
 * @type {String|null}
 * @memberOf WindowTransition
 */
_previousTransitionState: null,

/**
 * Handle the transition event.
 * @memberOf WindowTransition
 */
_transitionHandler: function aw__transitionHandler() {
  this._cancelTransition();
  this._processTransitionEvent(EVT.FINISH);
},

_cancelTransition: function aw__cancelTransition() {
  this.element.className.split(/\s+/).forEach(function(className) {
    if (className.indexOf('transition-') &gt;= 0) {
      this.element.classList.remove(className);
    }
  }, this);
},

_enterOpening: function aw__enterOpening(from, to, evt) {
  /**
   * @todo set this._unloaded
   */

  this.resize(null, null, true);
  if (this._unloaded) {
    //this.element.style.backgroundImage = 'url(' + this._splash + ')';
  }

  // Turn of visibility once we're entering opening state.
  this.setVisible(true);

  // Make sure the transition is terminated.
  this._openingTransitionTimer = window.setTimeout(function() {
    if (this._previousTransitionState &amp;&amp;
        this._previousTransitionState == from &amp;&amp;
        this._transitionState == to) {
      this._processTransitionEvent(EVT.END);
    }
  }.bind(this), this._transitionTimeout*1.2);

  /**
   * @event AppWindow#appwillopen
   * @memberof AppWindow
   */
  if (from !== 'opened') {
    // Only publish |willopen| event when previous state is "closed".
    this.publish('willopen');
  }
  this.element.classList.add('transition-opening');
  this.element.classList.add(this._transition['open']);
},

_enterClosing: function aw__enterClosing(from, to, evt) {
  // Make sure the transition is terminated.
  this._closingTransitionTimer = window.setTimeout(function() {
    if (this._previousTransitionState &amp;&amp;
        this._previousTransitionState == from &amp;&amp;
        this._transitionState == to) {
      this._processTransitionEvent(EVT.END);
    }
  }.bind(this), this._transitionTimeout*1.2);

  /**
   * @event AppWindow#appwillclose
   * @memberof AppWindow
   */

  if (from !== 'opened') {
    // Only publish |willclose| event when previous state is "opened".
    this.publish('willclose');
  }
  this.element.classList.add('transition-closing');
  this.element.classList.add(this._transition['close']);
},

_processTransitionEvent: function aw__processTransitionEvent(evt) {
  var to = transitionTable[this._transitionState][evt];

  if (to === null) {
    return;
  }

  var from = this._transitionState;

  this.leaveState(from, to, evt);
  this.onEvent(from, to, evt);
  this.enterState(from, to, evt);

  this._previousTransitionState = from;
  this._transitionState = to;
},

enterState: function aw_enterState(from, to, evt) {
  var funcName = '_enter' + capitalize(to.toLowerCase());
  if (typeof(this[funcName]) == 'function') {
    setTimeout(function(){
      this[funcName](from, to, evt);
    }.bind(this), 0);
  } else if (this[funcName] &amp;&amp; Array.isArray(this[funcName])) {
    this[funcName].forEach(function(func) {
      setTimeout(function(){
        func(from, to, evt);
      }.bind(this), 0);
    }, this);
  }
},

leaveState: function aw_leaveState(from, to, evt) {
  var funcName = '_leave' + capitalize(from.toLowerCase());
  if (typeof(this[funcName]) == 'function') {
    setTimeout(function(){
      this[funcName](from, to, evt);
    }.bind(this), 0);
  } else if (this[funcName] &amp;&amp; Array.isArray(this[funcName])) {
    this[funcName].forEach(function(func) {
      setTimeout(function(){
        func(from, to, evt);
      }.bind(this), 0);
    }, this);
  }
},

onEvent: function aw_onEvent(from, to, evt) {
  var funcName = '_onTransition' + capitalize(_EVTARRAY[evt].toLowerCase());
  this._invoke(funcName);
},

_enterOpened: function aw__enterOpened(from, to, evt) {
  this._cancelTransition();
  if (this._openingTransitionTimer) {
    window.clearTimeout(this._openingTransitionTimer);
    this._openingTransitionTimer = null;
  }
  this.element.classList.add('active');
  /**
   * @event AppWindow#appopen
   * @memberOf AppWindow
   */

  if (from == 'opening') {
    // Only publish |open| event when previous state is "opening".
    this.publish('open');
  }
},

_enterClosed: function aw__enterClosed(from, to, evt) {
  this._cancelTransition();
  if (this._closingTransitionTimer) {
    window.clearTimeout(this._closingTransitionTimer);
    this._closingTransitionTimer = null;
  }
  this.element.classList.remove('active');
  this.setVisible(false);

  /**
   * @event AppWindow#appclose
   * @memberof AppWindow
   */
  if (from == 'closing') {
    // Only publish |close| event when previous state is "closing".
    this.publish('close');
  }
},

/**
 * Set the transition way of opening or closing transition.
 * @param  {String} type       'open' or 'close'
 * @param  {String} transition The CSS rule name about window transition.
 * @memberOf WindowTransition
 */
_setTransition: function aw__setTransition(type, transition) {
  if (type != 'open' &amp;&amp; type != 'close')
    return;

  this._transition[type] = transition;
}
</code></pre>

<p>  };</p>

<p>  AppWindow.addMixin(WindowTransition);
}(this));
```</p>

<h5>The state machine's usage and notes</h5>

<ol>
<li>A single app window instance would send 'open' and 'close' event due to user action:
<code>
transitionStateMachine.<em>processEvent('open');
transitionStateMachine.</em>processEvent('close');
</code>
Note, app window doesn't need to know current state of the state machine.</li>
<li>The state machine itself is the one who creates/removes the timer which triggers timeout event. I am also thinking about moving this out of the state machine and do this in another mixin, only have the callback functions provided by the state machine. But I am not sure.</li>
<li>The state machine has some callback for others(other state machine!) listed below:

<ul>
<li>Enter a state successfully.</li>
<li>Leave a state successfully.</li>
<li>When an event triggers state switch successfully.
In all these callback we would get the previous state and current state, and the event who triggers them.</li>
</ul>
</li>
<li>The CSS class for real UI closing animation is added in <code><em>enterClosing</code> and removed in <code></em>enterClosed</code>. Or else we could do that in <code><em>leaveOpened</code> and <code></em>leaveClosing</code>. I have no strong opinion here.
Maybe we could define the level of the callback into three here, according to the callback order.</li>
<li>The CSS class for real UI opening animation is added in <code><em>enterOpening</code> and removed in <code></em>enterOpened</code>.</li>
<li>We could also move out (4) and (5) to another mixin to purify the state machine.</li>
</ol>


<p>Finally, back to the problems addressed in Tim's article:</p>

<ul>
<li>Do we need intermediate state?

<ul>
<li>I don't think so, at least for now. If we really need to goto next state when we successfully from state A to state B, we could call <code>_processEvent</code> again in the inner callback of the state machine. This doesn't violate the policy that only state machine ifself could decide its next state.</li>
<li>If the intermediate state needs to acquire other type of state -- just fetch the current state of the other state machine. Or, if we need, register an one-time callback if the current state doesn't meet our requirement.</li>
</ul>
</li>
<li>How about state conflict between two apps?

<ul>
<li>That won't happen if we deal with the state changes correctly and independently in each app's scope. I hope so.</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript從變形矩陣反推scale以及rotate]]></title>
    <link href="http://alivedise.github.com/blog/2013/05/27/rotation-matrix/"/>
    <updated>2013-05-27T15:41:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2013/05/27/rotation-matrix</id>
    <content type="html"><![CDATA[<p>原文：
<a href="http://css-tricks.com/get-value-of-css-rotation-through-javascript/">http://css-tricks.com/get-value-of-css-rotation-through-javascript/</a></p>

<p>今天在追一個跟CSS3 transform有關的bug，
過程中懷疑是transform沒有正確應用到element上。</p>

<p>最後想到用一個Mutation Observer去觀察元素的變形矩陣的某個值（在此例為scale)的變化，
因為transform沒辦法直接用element.style直接拿到scale的值，
所以要用getComputedStyle拿出變形矩陣後算出來：
（skew跟translate的值原文沒有提供算法，看了一下網路文章似乎沒辦法逆推。）</p>

<p>```js
  /<em>*
   * Construct a mutation observer.
   * See https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
   </em>/</p>

<p>  /<strong>
   * var target = document.querySelector('#id');
   */
  var target = document.querySelector('#id');
  /</strong>
   * create an observer instance
   */
  var observer = new MutationObserver(function(mutations) {</p>

<pre><code>/**
 * We could iterate the mutations here,
 * but I don't really care it now.
 */
var st = window.getComputedStyle(target, null);
var tr = st.getPropertyValue("-webkit-transform") ||
         st.getPropertyValue("-moz-transform") ||
         st.getPropertyValue("-ms-transform") ||
         st.getPropertyValue("-o-transform") ||
         st.getPropertyValue("transform");

console.log('Matrix: ' + tr);

// rotation matrix - http://en.wikipedia.org/wiki/Rotation_matrix

var values = tr.split('(')[1];
values = values.split(')')[0];
values = values.split(',');
var a = values[0];
var b = values[1];
var c = values[2];
var d = values[3];

var scale = Math.sqrt(a*a + b*b);

// arc sin, convert from radians to degrees, round
// DO NOT USE: see update below
var sin = b/scale;
var angle = Math.round(Math.asin(sin) * (180/Math.PI));

// works!
console.log('Scale: ' + scale + ';Rotate: ' + angle + 'deg');
</code></pre>

<p>  });
  /**</p>

<pre><code>* Configuration of mutation observer.
*/
</code></pre>

<p>  var config = { attributes: true, childList: true, characterData: true };</p>

<p>  /<em>*
   * pass in the target node, as well as the observer options
   </em>/
  observer.observe(target, config);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocha: MockMozActivity與global leak]]></title>
    <link href="http://alivedise.github.com/blog/2013/02/23/mock-moz-activity/"/>
    <updated>2013-02-23T16:56:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2013/02/23/mock-moz-activity</id>
    <content type="html"><![CDATA[<p>之前在寫單元測試時，需要測到MozActivity的呼叫。</p>

<p>當我們嘗試去取代window object中的MozActivity時，會遇到：</p>

<p><code>
0) Feed "before all" hook: Error: global leak detected:
</code></p>

<p>解決方法：</p>

<p>在程式前面加上<code>mocha.setup({ignoreLeaks: true});</code></p>

<p>最後加上<code>mocha.setup({ignoreLeaks: true});</code></p>

<p>碰到這個錯誤是在嘗試加入假的MozActivity給window時。</p>

<p>因為要被測試的module中有如下的程式片段：</p>

<p>``` js
  new MozActivity({</p>

<pre><code>name: 'view',
data: { type: 'url', url: url }
</code></pre>

<p>  });</p>

<p>```</p>

<p>去呼叫browser app開啟某個特定網頁，</p>

<p>但是mocha跑的環境中有可能：</p>

<ol>
<li>並沒有window.MozActivity這個物件。</li>
<li>有MozActivity但是我們無法知道他是否被呼叫。</li>
</ol>


<p>這時候需要塞一個MockMozActivity給window，暫時取代掉原本的MozActivity，</p>

<p>然後從MockMozActivity裡面留個變數記錄被呼叫的參數狀況來判斷程式是否正確的執行呼叫activity。</p>

<p>``` js
'use strict';</p>

<p>var mockMozActivityInstance = null;</p>

<p>var MockMozActivity = function MozActivity(configuration) {
  for (var property in configuration) {</p>

<pre><code>this[property] = configuration[property];
</code></pre>

<p>  }
  mockMozActivityInstance = this;
  return this;
};</p>

<p>```</p>

<p>之後寫的測試內容：</p>

<p>``` js
// Captive Portal Test
  test('system/captive portal login w/o manual enable wifi', function() {</p>

<pre><code>CaptivePortal.handleEvent(event);
MockSettingsListener.mCallback(true);
assert.equal(mockMozActivityInstance.name, 'view');
</code></pre>

<p>  });
```</p>

<p>人生第一個單元測試程式完成 \O/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript memorization]]></title>
    <link href="http://alivedise.github.com/blog/2012/12/22/javascript-memorization/"/>
    <updated>2012-12-22T00:28:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2012/12/22/javascript-memorization</id>
    <content type="html"><![CDATA[<p>As you know, function in javascript is also an object,
you could use a property of the object to keep function result.
This is called <code>Memorization</code>.</p>

<p>Today I have a chance to utilize this skill.</p>

<p>Please read codes below first:</p>

<p>``` javascript</p>

<pre><code>} else if (getOffOrigin(app.frame.dataset.url ? app.frame.dataset.url : app.frame.src, origin)) {
  var subtitle = document.createElement('p');
  subtitle.textContent = getOffOrigin(app.frame.dataset.url ? app.frame.dataset.url : app.frame.src, origin);
  card.appendChild(subtitle);
}
</code></pre>

<p>```</p>

<p><code>getOffOrigin</code> has to use some logic to compare the two arguments and return a string.
The result wouldn't change if the arguments are the same.
Therefore, to avoid calling the function many times, the result could be stored in the function itself.</p>

<p>``` javascript
  function getOffOrigin(src, origin) {</p>

<pre><code>// Use src and origin as cache key
var cacheKey = JSON.stringify(Array.prototype.slice.call(arguments));
if (!getOffOrigin.cache[cacheKey]) {
  var native = getOriginObject(origin);
  var current = getOriginObject(src);
  if (current.protocol == 'http:') {
    // Display http:// protocol anyway
    getOffOrigin.cache[cacheKey] = current.protocol + '//' + current.hostname;
  } else if (native.protocol == current.protocol &amp;&amp;
      native.hostname == current.hostname &amp;&amp;
      native.port == current.port) {
    // Same origin policy
    getOffOrigin.cache[cacheKey] = '';
  } else if (current.protocol == 'app:') {
    // Avoid displaying app:// protocol
    getOffOrigin.cache[cacheKey] = '';
  } else {
    getOffOrigin.cache[cacheKey] = current.protocol + '//' + current.hostname;
  }
}

return getOffOrigin.cache[cacheKey];
</code></pre>

<p>  }
  getOffOrigin.cache = {};
```
* If we only have one arguments we could use it as the key to cache directly.
  But we have multiple arguments in this case, we then use stringilized JSON to be the key.</p>

<ul>
<li><p>Hence we don't need to do the same thing every time we enter this function if the arguments are used before.</p></li>
<li><p>Have fun with your function cache!</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[gaia] HTML5 Window Shade]]></title>
    <link href="http://alivedise.github.com/blog/2012/07/05/gaia-window-shade/"/>
    <updated>2012-07-05T13:58:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2012/07/05/gaia-window-shade</id>
    <content type="html"><![CDATA[<h1>Window Shade</h1>

<p>我手上的Samsung Galaxy S3的作業系統是Android 4.0.4。</p>

<p>當我收到facebook/google+/...等程式通知的時候，最上面那條bar會出現對應的圖示。</p>

<p>這時候可以透過將bar「滑下來」的動作拉出一個UI，裡面會有</p>

<ol>
<li>快速設定</li>
<li>通知項目詳細列表</li>
</ol>


<p><img src="http://i.imgur.com/nU76i.png"></p>

<p>這個UX，Google把它稱為<b>Window shade</b></p>

<p>神奇的地方在於當你在拉下或拉上面板的同時，
快速設定與通知項目是會先「掉下來」到底端，
到了項目的頂端出現之後才會黏在頂部。
（相信我你沒有特別注意這件事情，而且用久了會覺得理所當然）</p>

<h1>GAIA也有notification panel</h1>

<p>Firefox OS的UI - <a href="http://github.com/mozilla-central/gaia">GAIA</a>裡面也有定義功能列以及通知面板這件事，
這個功能正在開發中。</p>

<p>有一天我們收到某個contributor提交的pull request：</p>

<p><a href="https://github.com/mozilla-b2g/gaia/pull/1898">Gaia pull request#1898</a>
節錄重要的修改如下：</p>

<p>``` javascript
  onTouchMove: function ut_onTouchMove(touch) {</p>

<pre><code>var screenHeight = this.overlay.getBoundingClientRect().height,
    gripBarHeight = this.gripBar.getBoundingClientRect().height,
    dy = -(this.startY - touch.pageY),
    newHeight;
if (this.shown)
  dy += screenHeight;
dy = Math.min(screenHeight, dy);

if (dy &gt; gripBarHeight) {
  var quickSettingsHeight = this.quickSettings.getBoundingClientRect().height;

  if (dy &lt; quickSettingsHeight + gripBarHeight) {
    newHeight = screenHeight - quickSettingsHeight - gripBarHeight;
  } else {
    newHeight = screenHeight - dy;
  }
  this.quickSettings.style.MozTransition = '';
  this.quickSettings.style.MozTransform = 'translateY(' + newHeight + 'px)';
}

var style = this.overlay.style;
style.MozTransition = '';
style.MozTransform = 'translateY(' + dy + 'px)';
</code></pre>

<p>  },
  //....skiped...
  show: function ut_show(dy) {</p>

<pre><code>var alreadyShown = this.shown,
    trayStyle = this.overlay.style,
    quickSettingsStyle = this.quickSettings.style;

trayStyle.MozTransition = '-moz-transform 0.2s linear';
trayStyle.MozTransform = 'translateY(100%)';

quickSettingsStyle.MozTransition = '-moz-transform 0.2s linear';
quickSettingsStyle.MozTransform = 'translateY(0px)';

this.shown = true;
this.screen.classList.add('utility-tray');

if (!alreadyShown) {
  var evt = document.createEvent('CustomEvent');
  evt.initCustomEvent('utilitytrayshow', true, true, null);
  window.dispatchEvent(evt);
}
</code></pre>

<p>  }
```</p>

<p>原作者提到他做這件事是要讓<code>quick-setting</code>更快的出現。
這段code也已經被merge了。</p>

<h1>不過就在昨天同事發現了一個關於功能列的issue</h1>

<p>於是我開始看發生了什麼事。然後上面那兩個function耗費了我一個下午....XD</p>

<p>@colinfrei其實做了一件非常有趣但是很難從code裡面看出端倪的事情。
甚至也很難用語言來描述，不過我想試著說明發生了什麼事，怎麼做到的。</p>

<p>簡單的說，他利用兩個「不同」區塊的CSS3的Transition「同步化」來實現剛剛所提的Window Shade的行為。</p>

<h2>CSS: Transition</h2>

<p><a href="https://developer.mozilla.org/en/CSS/transition">參閱MDN: transition</a></p>

<h2>CSS: Transform</h2>

<p><a href="https://developer.mozilla.org/en/CSS/transform">參閱MDN: transform</a></p>

<h1>真相其實是：</h1>

<ol>
<li><code>utility-tray</code>是一個絕對定位的<code>div</code>，平常位置定在螢幕上方<code>-moz-calc(100% - UTILITY_TRAY_HEIGHT)</code>。</li>
<li><p>當你開始Touch的時候，根據你的移動距離計算<code>translateY</code>，使它產生位移</p>

<p> 你可以把<code>-moz-transform: translateY(px)</code>當成是<code>top: px</code>在CSS3的新招。
 它提供了更快速的rendering -- 當你想利用<code>-moz-transition: -moz-transform</code>來做位移動畫的時候。
 這件事情可以另外寫一篇文章來說（挖洞的意味）。</p></li>
<li><p>當你放開拉bar的時候而且如果已經超過「要讓通知面板掉下來的合法距離」：</p>

<ul>
<li>設定一個<code>MozTransition</code>給<code>utility-tray-overlay</code></li>
<li>再設定一個<code>MozTransition</code>給<code>quick-setting</code></li>
</ul>
</li>
</ol>


<p>4.讓<code>utility-tray</code>整個以某個定速掉下來到螢幕底端 + 讓<code>quick-setting</code>以同樣的定速往上移動到<code>utility-tray</code>的開端</p>

<p>  = 於是就造成了<code>quick-setting</code>似乎黏在通知列下方不動但整個面板是往下掉的假象！</p>

<h1>the story continues</h1>

<p>不過可惜的是似乎沒有考慮到當通知面板要滑上去的時候，</p>

<p>「有物件的部份也應該留在頂端直到被拉bar撞到一起彈上去」這件事</p>

<p>於是我也仿造這個作法另外送了一個pull request</p>

<p><a href="https://github.com/mozilla-b2g/gaia/pull/2181">GAIA pull request#2181</a>
``` javascript</p>

<pre><code>  case 'transitionend':
    if (!this.shown) {
      this.screen.classList.remove('utility-tray');

      var overlayStyle = this.overlay;
      var firstShownStyle = this.firstShowStyle;
      firstShownStyle.MozTransition = '';

      if (this.phase2hide) {
        firstShownStyle.MozTransition = '-moz-transform 0.2s linear';
        firstShownStyle.MozTransform =
          'translateY(' + this.firstShownPosition + 'px)';
        overlayStyle.MozTransition = '-moz-transform 0.2s linear';
        overlayStyle.MozTransform = 'translateY(0)';

        // Check the transition event is triggered at firstShown.
        // If so, turn off the flag which represent for
        // 'The overlay has already reached the bottom of quick-setting'
        if (evt.target == this.firstShown)
          this.phase2hide = false;
      } else {
        // Reset position of this.firstShown
        this.firstShown.style.MozTransition = '';
        this.firstShown.style.MozTransform = 'translateY(0)';
      }
    }
    break;
</code></pre>

<p>```</p>

<p>利用<code>transitionend</code> event callback，透過連續兩次的<code>Transition</code>來：</p>

<ol>
<li>讓<code>utility-tray</code>先定速往上移動/讓<code>quick-setting</code>定速往下移動到底端。</li>
<li>等到<code>utility-tray</code>的transition結束時，會收到<code>transitionend</code>的事件。
 這時候再讓<code>utility-tray</code>進行第二次transition...而目的地就是螢幕頂端。
 同時<code>quick-setting</code>就不再動作了，讓它跟著<code>utility-tray</code>一起被往上卷走。</li>
</ol>


<h2>transitionend</h2>

<p><a href="https://developer.mozilla.org/zh_tw/CSS_%E8%BD%89%E5%A0%B4#.E5.81.B5.E6.B8.AC_transition_.E7.9A.84.E5.AE.8C.E6.88.90">參閱MDN: transitionend</a></p>

<h1>the end?</h1>

<p>其實UX還沒有定義這個行為，所以pull request本身沒有被接受。
不過...I did learn something from these codes:)</p>
]]></content>
  </entry>
  
</feed>
