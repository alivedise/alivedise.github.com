<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Ascheriit]]></title>
  <link href="http://alivedise.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://alivedise.github.com/"/>
  <updated>2013-07-03T19:36:30+08:00</updated>
  <id>http://alivedise.github.com/</id>
  <author>
    <name><![CDATA[Alive Kuo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Javascript從變形矩陣反推scale以及rotate]]></title>
    <link href="http://alivedise.github.com/blog/2013/05/27/rotation-matrix/"/>
    <updated>2013-05-27T15:41:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2013/05/27/rotation-matrix</id>
    <content type="html"><![CDATA[<p>原文：
<a href="http://css-tricks.com/get-value-of-css-rotation-through-javascript/">http://css-tricks.com/get-value-of-css-rotation-through-javascript/</a></p>

<p>今天在追一個跟CSS3 transform有關的bug，
過程中懷疑是transform沒有正確應用到element上。</p>

<p>最後想到用一個Mutation Observer去觀察元素的變形矩陣的某個值（在此例為scale)的變化，
因為transform沒辦法直接用element.style直接拿到scale的值，
所以要用getComputedStyle拿出變形矩陣後算出來：
（skew跟translate的值原文沒有提供算法，看了一下網路文章似乎沒辦法逆推。）</p>

<p>```js
  /<em>*
   * Construct a mutation observer.
   * See https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
   </em>/</p>

<p>  /<strong>
   * var target = document.querySelector('#id');
   */
  var target = document.querySelector('#id');
  /</strong>
   * create an observer instance
   */
  var observer = new MutationObserver(function(mutations) {</p>

<pre><code>/**
 * We could iterate the mutations here,
 * but I don't really care it now.
 */
var st = window.getComputedStyle(target, null);
var tr = st.getPropertyValue("-webkit-transform") ||
         st.getPropertyValue("-moz-transform") ||
         st.getPropertyValue("-ms-transform") ||
         st.getPropertyValue("-o-transform") ||
         st.getPropertyValue("transform");

console.log('Matrix: ' + tr);

// rotation matrix - http://en.wikipedia.org/wiki/Rotation_matrix

var values = tr.split('(')[1];
values = values.split(')')[0];
values = values.split(',');
var a = values[0];
var b = values[1];
var c = values[2];
var d = values[3];

var scale = Math.sqrt(a*a + b*b);

// arc sin, convert from radians to degrees, round
// DO NOT USE: see update below
var sin = b/scale;
var angle = Math.round(Math.asin(sin) * (180/Math.PI));

// works!
console.log('Scale: ' + scale + ';Rotate: ' + angle + 'deg');
</code></pre>

<p>  });
  /**</p>

<pre><code>* Configuration of mutation observer.
*/
</code></pre>

<p>  var config = { attributes: true, childList: true, characterData: true };</p>

<p>  /<em>*
   * pass in the target node, as well as the observer options
   </em>/
  observer.observe(target, config);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocha: MockMozActivity與global leak]]></title>
    <link href="http://alivedise.github.com/blog/2013/02/23/mock-moz-activity/"/>
    <updated>2013-02-23T16:56:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2013/02/23/mock-moz-activity</id>
    <content type="html"><![CDATA[<p>之前在寫單元測試時，需要測到MozActivity的呼叫。</p>

<p>當我們嘗試去取代window object中的MozActivity時，會遇到：</p>

<p><code>
0) Feed "before all" hook: Error: global leak detected:
</code></p>

<p>解決方法：</p>

<p>在程式前面加上<code>mocha.setup({ignoreLeaks: true});</code></p>

<p>最後加上<code>mocha.setup({ignoreLeaks: true});</code></p>

<p>碰到這個錯誤是在嘗試加入假的MozActivity給window時。</p>

<p>因為要被測試的module中有如下的程式片段：</p>

<p>``` js
  new MozActivity({</p>

<pre><code>name: 'view',
data: { type: 'url', url: url }
</code></pre>

<p>  });</p>

<p>```</p>

<p>去呼叫browser app開啟某個特定網頁，</p>

<p>但是mocha跑的環境中有可能：</p>

<ol>
<li>並沒有window.MozActivity這個物件。</li>
<li>有MozActivity但是我們無法知道他是否被呼叫。</li>
</ol>


<p>這時候需要塞一個MockMozActivity給window，暫時取代掉原本的MozActivity，</p>

<p>然後從MockMozActivity裡面留個變數記錄被呼叫的參數狀況來判斷程式是否正確的執行呼叫activity。</p>

<p>``` js
'use strict';</p>

<p>var mockMozActivityInstance = null;</p>

<p>var MockMozActivity = function MozActivity(configuration) {
  for (var property in configuration) {</p>

<pre><code>this[property] = configuration[property];
</code></pre>

<p>  }
  mockMozActivityInstance = this;
  return this;
};</p>

<p>```</p>

<p>之後寫的測試內容：</p>

<p>``` js
// Captive Portal Test
  test('system/captive portal login w/o manual enable wifi', function() {</p>

<pre><code>CaptivePortal.handleEvent(event);
MockSettingsListener.mCallback(true);
assert.equal(mockMozActivityInstance.name, 'view');
</code></pre>

<p>  });
```</p>

<p>人生第一個單元測試程式完成 \O/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript memorization]]></title>
    <link href="http://alivedise.github.com/blog/2012/12/22/javascript-memorization/"/>
    <updated>2012-12-22T00:28:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2012/12/22/javascript-memorization</id>
    <content type="html"><![CDATA[<p>As you know, function in javascript is also an object,
you could use a property of the object to keep function result.
This is called <code>Memorization</code>.</p>

<p>Today I have a chance to utilize this skill.</p>

<p>Please read codes below first:</p>

<p>``` javascript</p>

<pre><code>} else if (getOffOrigin(app.frame.dataset.url ? app.frame.dataset.url : app.frame.src, origin)) {
  var subtitle = document.createElement('p');
  subtitle.textContent = getOffOrigin(app.frame.dataset.url ? app.frame.dataset.url : app.frame.src, origin);
  card.appendChild(subtitle);
}
</code></pre>

<p>```</p>

<p><code>getOffOrigin</code> has to use some logic to compare the two arguments and return a string.
The result wouldn't change if the arguments are the same.
Therefore, to avoid calling the function many times, the result could be stored in the function itself.</p>

<p>``` javascript
  function getOffOrigin(src, origin) {</p>

<pre><code>// Use src and origin as cache key
var cacheKey = JSON.stringify(Array.prototype.slice.call(arguments));
if (!getOffOrigin.cache[cacheKey]) {
  var native = getOriginObject(origin);
  var current = getOriginObject(src);
  if (current.protocol == 'http:') {
    // Display http:// protocol anyway
    getOffOrigin.cache[cacheKey] = current.protocol + '//' + current.hostname;
  } else if (native.protocol == current.protocol &amp;&amp;
      native.hostname == current.hostname &amp;&amp;
      native.port == current.port) {
    // Same origin policy
    getOffOrigin.cache[cacheKey] = '';
  } else if (current.protocol == 'app:') {
    // Avoid displaying app:// protocol
    getOffOrigin.cache[cacheKey] = '';
  } else {
    getOffOrigin.cache[cacheKey] = current.protocol + '//' + current.hostname;
  }
}

return getOffOrigin.cache[cacheKey];
</code></pre>

<p>  }
  getOffOrigin.cache = {};
```
* If we only have one arguments we could use it as the key to cache directly.
  But we have multiple arguments in this case, we then use stringilized JSON to be the key.</p>

<ul>
<li><p>Hence we don't need to do the same thing every time we enter this function if the arguments are used before.</p></li>
<li><p>Have fun with your function cache!</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[gaia] HTML5 Window Shade]]></title>
    <link href="http://alivedise.github.com/blog/2012/07/05/gaia-window-shade/"/>
    <updated>2012-07-05T13:58:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2012/07/05/gaia-window-shade</id>
    <content type="html"><![CDATA[<h1>Window Shade</h1>

<p>我手上的Samsung Galaxy S3的作業系統是Android 4.0.4。</p>

<p>當我收到facebook/google+/...等程式通知的時候，最上面那條bar會出現對應的圖示。</p>

<p>這時候可以透過將bar「滑下來」的動作拉出一個UI，裡面會有</p>

<ol>
<li>快速設定</li>
<li>通知項目詳細列表</li>
</ol>


<p><img src="http://i.imgur.com/nU76i.png"></p>

<p>這個UX，Google把它稱為<b>Window shade</b></p>

<p>神奇的地方在於當你在拉下或拉上面板的同時，
快速設定與通知項目是會先「掉下來」到底端，
到了項目的頂端出現之後才會黏在頂部。
（相信我你沒有特別注意這件事情，而且用久了會覺得理所當然）</p>

<h1>GAIA也有notification panel</h1>

<p>Firefox OS的UI - <a href="http://github.com/mozilla-central/gaia">GAIA</a>裡面也有定義功能列以及通知面板這件事，
這個功能正在開發中。</p>

<p>有一天我們收到某個contributor提交的pull request：</p>

<p><a href="https://github.com/mozilla-b2g/gaia/pull/1898">Gaia pull request#1898</a>
節錄重要的修改如下：</p>

<p>``` javascript
  onTouchMove: function ut_onTouchMove(touch) {</p>

<pre><code>var screenHeight = this.overlay.getBoundingClientRect().height,
    gripBarHeight = this.gripBar.getBoundingClientRect().height,
    dy = -(this.startY - touch.pageY),
    newHeight;
if (this.shown)
  dy += screenHeight;
dy = Math.min(screenHeight, dy);

if (dy &gt; gripBarHeight) {
  var quickSettingsHeight = this.quickSettings.getBoundingClientRect().height;

  if (dy &lt; quickSettingsHeight + gripBarHeight) {
    newHeight = screenHeight - quickSettingsHeight - gripBarHeight;
  } else {
    newHeight = screenHeight - dy;
  }
  this.quickSettings.style.MozTransition = '';
  this.quickSettings.style.MozTransform = 'translateY(' + newHeight + 'px)';
}

var style = this.overlay.style;
style.MozTransition = '';
style.MozTransform = 'translateY(' + dy + 'px)';
</code></pre>

<p>  },
  //....skiped...
  show: function ut_show(dy) {</p>

<pre><code>var alreadyShown = this.shown,
    trayStyle = this.overlay.style,
    quickSettingsStyle = this.quickSettings.style;

trayStyle.MozTransition = '-moz-transform 0.2s linear';
trayStyle.MozTransform = 'translateY(100%)';

quickSettingsStyle.MozTransition = '-moz-transform 0.2s linear';
quickSettingsStyle.MozTransform = 'translateY(0px)';

this.shown = true;
this.screen.classList.add('utility-tray');

if (!alreadyShown) {
  var evt = document.createEvent('CustomEvent');
  evt.initCustomEvent('utilitytrayshow', true, true, null);
  window.dispatchEvent(evt);
}
</code></pre>

<p>  }
```</p>

<p>原作者提到他做這件事是要讓<code>quick-setting</code>更快的出現。
這段code也已經被merge了。</p>

<h1>不過就在昨天同事發現了一個關於功能列的issue</h1>

<p>於是我開始看發生了什麼事。然後上面那兩個function耗費了我一個下午....XD</p>

<p>@colinfrei其實做了一件非常有趣但是很難從code裡面看出端倪的事情。
甚至也很難用語言來描述，不過我想試著說明發生了什麼事，怎麼做到的。</p>

<p>簡單的說，他利用兩個「不同」區塊的CSS3的Transition「同步化」來實現剛剛所提的Window Shade的行為。</p>

<h2>CSS: Transition</h2>

<p><a href="https://developer.mozilla.org/en/CSS/transition">參閱MDN: transition</a></p>

<h2>CSS: Transform</h2>

<p><a href="https://developer.mozilla.org/en/CSS/transform">參閱MDN: transform</a></p>

<h1>真相其實是：</h1>

<ol>
<li><code>utility-tray</code>是一個絕對定位的<code>div</code>，平常位置定在螢幕上方<code>-moz-calc(100% - UTILITY_TRAY_HEIGHT)</code>。</li>
<li><p>當你開始Touch的時候，根據你的移動距離計算<code>translateY</code>，使它產生位移</p>

<p> 你可以把<code>-moz-transform: translateY(px)</code>當成是<code>top: px</code>在CSS3的新招。
 它提供了更快速的rendering -- 當你想利用<code>-moz-transition: -moz-transform</code>來做位移動畫的時候。
 這件事情可以另外寫一篇文章來說（挖洞的意味）。</p></li>
<li><p>當你放開拉bar的時候而且如果已經超過「要讓通知面板掉下來的合法距離」：</p>

<ul>
<li>設定一個<code>MozTransition</code>給<code>utility-tray-overlay</code></li>
<li>再設定一個<code>MozTransition</code>給<code>quick-setting</code></li>
</ul>
</li>
</ol>


<p>4.讓<code>utility-tray</code>整個以某個定速掉下來到螢幕底端 + 讓<code>quick-setting</code>以同樣的定速往上移動到<code>utility-tray</code>的開端</p>

<p>  = 於是就造成了<code>quick-setting</code>似乎黏在通知列下方不動但整個面板是往下掉的假象！</p>

<h1>the story continues</h1>

<p>不過可惜的是似乎沒有考慮到當通知面板要滑上去的時候，</p>

<p>「有物件的部份也應該留在頂端直到被拉bar撞到一起彈上去」這件事</p>

<p>於是我也仿造這個作法另外送了一個pull request</p>

<p><a href="https://github.com/mozilla-b2g/gaia/pull/2181">GAIA pull request#2181</a>
``` javascript</p>

<pre><code>  case 'transitionend':
    if (!this.shown) {
      this.screen.classList.remove('utility-tray');

      var overlayStyle = this.overlay;
      var firstShownStyle = this.firstShowStyle;
      firstShownStyle.MozTransition = '';

      if (this.phase2hide) {
        firstShownStyle.MozTransition = '-moz-transform 0.2s linear';
        firstShownStyle.MozTransform =
          'translateY(' + this.firstShownPosition + 'px)';
        overlayStyle.MozTransition = '-moz-transform 0.2s linear';
        overlayStyle.MozTransform = 'translateY(0)';

        // Check the transition event is triggered at firstShown.
        // If so, turn off the flag which represent for
        // 'The overlay has already reached the bottom of quick-setting'
        if (evt.target == this.firstShown)
          this.phase2hide = false;
      } else {
        // Reset position of this.firstShown
        this.firstShown.style.MozTransition = '';
        this.firstShown.style.MozTransform = 'translateY(0)';
      }
    }
    break;
</code></pre>

<p>```</p>

<p>利用<code>transitionend</code> event callback，透過連續兩次的<code>Transition</code>來：</p>

<ol>
<li>讓<code>utility-tray</code>先定速往上移動/讓<code>quick-setting</code>定速往下移動到底端。</li>
<li>等到<code>utility-tray</code>的transition結束時，會收到<code>transitionend</code>的事件。
 這時候再讓<code>utility-tray</code>進行第二次transition...而目的地就是螢幕頂端。
 同時<code>quick-setting</code>就不再動作了，讓它跟著<code>utility-tray</code>一起被往上卷走。</li>
</ol>


<h2>transitionend</h2>

<p><a href="https://developer.mozilla.org/zh_tw/CSS_%E8%BD%89%E5%A0%B4#.E5.81.B5.E6.B8.AC_transition_.E7.9A.84.E5.AE.8C.E6.88.90">參閱MDN: transitionend</a></p>

<h1>the end?</h1>

<p>其實UX還沒有定義這個行為，所以pull request本身沒有被接受。
不過...I did learn something from these codes:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[WEB] Web Application Core]]></title>
    <link href="http://alivedise.github.com/blog/2012/06/10/web-application-core/"/>
    <updated>2012-06-10T17:06:00+08:00</updated>
    <id>http://alivedise.github.com/blog/2012/06/10/web-application-core</id>
    <content type="html"><![CDATA[<p>最近看到這篇文章<a href="http://addyosmani.github.com/backbone-aura/">Backbone Aura</a>難得的有提到一個web application core該做些什麼事情？跟我想的蠻相似的，這邊將他列出來：
* 管理widget的life cycle的能力。
* 低階DOM操作處理
* 提供publish/subscribe的溝通管道給應用程式的各部位互相溝通</p>

<p>以下是我流解析。</p>

<h2>管理widget的life cycle</h2>

<p>Core是應用程式的進入點(entry poing)，它必須在適當的時機init需要的widget/application part起來做事情，也只有Core才知道什麼時候必須做這些事情。當然也包括在適當的時機讓widget沈睡或消滅。</p>

<h2>低階DOM操作</h2>

<p>這有點像jQuery library主要在做的事情，不過世界上不是只有jQuery一種library，也不是任何情況下都可以用jQuery，有一個可以快速操作DOM的方法是必要的。</p>

<h2>提供publish/subscribe的溝通方式</h2>

<p>解耦後的application part/widget當然不能直接呼叫別人的attribute function（不然還解什麼耦），那要怎麼叫別人做事？行之有年的publish/subscribe機制在jmvc已經被整合進去，backbone上面還欠缺方法，backbone aura把這件事做出來了。</p>

<p>然後因為好奇它怎麼做的就看了一下source，在<code>aura/www/js/aura/mediator.js</code>裡面定義了：</p>

<p>``` js</p>

<pre><code>/**
 * Subscribe to an event
 * @param {string} channel Event name
 * @param {object} subscription Module callback
 * @param {object} context Context in which to execute the module
 */
obj.subscribe = function (channel, callback, context) {
    channels[channel] = (!channels[channel]) ? [] : channels[channel];
    channels[channel].push(this.util.method(callback, context));
};

/**
 * Publish an event, passing arguments to subscribers. Will
 * call start if the channel is not already registered.
 * @param {string} channel Event name
 */
obj.publish = function (channel) {
    var i, l, args = [].slice.call(arguments, 1);
    if (!channels[channel]) {
        obj.start.apply(this, arguments);
        return;
    }

    for (i = 0, l = channels[channel].length; i &lt; l; i += 1) {
        channels[channel][i].apply(this, args);
    }
};
</code></pre>

<p>```</p>

<p>看起來是利用一個變數來根據widget name儲存callback function進array裡面。</p>
]]></content>
  </entry>
  
</feed>
